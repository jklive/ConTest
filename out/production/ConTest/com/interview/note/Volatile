---》volatile是什么

volatile是Java虚拟机提供的轻量级同步机制
三大特性：
> 保证可见性：例 其中一个线程修改了主内存变量值，并写回主程序，及时通知其他线程
           各个线程对主内存共享变量的操作都会拷贝到自己的工作内存去操作，
           一个线程同理在自己工作内存中修改了共享变量的值，还未写回主内存，另一个
           线程也要修改同一个变量，但是此时它对上一个线程正在修改不知情，即A线程中
           共享变量的值对B线程不可见，这种工作内存与主内存同步延迟现象即可见性问题

> 不保证原子性
           即不可分割性，完整性，即某个线程执行某个具体任务时，中间不可以被加塞或者分割，
           需要整体完整，即整体要么同时成功，要么同时失败


> 禁止指令重排

---》JMM 即Java Memory Model（Java内存模型）
并不真实存在，只是一种约束或规范，规定了三大特性，可见性，原子性，有序性


由于JVM运行程序时，实体是一个一个线程被创建，而每个线程新创建，JVM都会为其分配一个私有的工作内存，（即
每个线程自己的栈内存），这个工作内存是每个线程私有的数据空间，而Java内存模型规定，所有的变量都存储在主内存
主内存是所有线程共享的，但是各个线程对这些变量会有不同的操作，所以各个线程对变量的操作都会在各个线程私有的
工作内存中进行，怎么做呢，肯定要将主内存中的变量拷贝一份到自己的工作内存，操作完成后裔再讲变量写回主内存
因为主内存是所有运行线程共享的，所以单个线程肯定不能直接操作主内存的变量，由于工作内存各线程私有，其他线程
无法访问非自己的工作内存，线程间的通讯当然要靠主内存来完成



-》JMM关于同步的规定
> 线程解锁前，必须把共享变量的值刷新回主内存
> 线程加锁前，必须读取主内存的最新值到工作内存
> 线程加锁解锁是同一把锁
